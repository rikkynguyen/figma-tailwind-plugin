figma.showUI(__html__, { width: 420, height: 600 });
figma.ui.onmessage = async function(msg) {
  if (msg.type === "resize") {
    figma.ui.resize(msg.width, msg.height);
  }
  if (msg.type === "get-collections") {
    const collections = await figma.variables.getLocalVariableCollectionsAsync();
    const variables = await figma.variables.getLocalVariablesAsync();
    const nonEmptyCollections = collections.filter(
      (c) => variables.some((v) => v.variableCollectionId === c.id)
    );
    figma.ui.postMessage({
      type: "collections",
      collections: nonEmptyCollections.map((c) => ({
        id: c.id,
        name: c.name || "(Unnamed)",
        defaultModeId: c.defaultModeId,
        modes: c.modes
      })),
      variables
      // send variables if needed for UI
    });
  }
  if (msg.type === "export-css") {
    const selectedIds = msg.selected;
    const allCollections = await figma.variables.getLocalVariableCollectionsAsync();
    const allVariables = await figma.variables.getLocalVariablesAsync();
    const nonEmptyCollections = allCollections.filter(
      (c) => allVariables.some((v) => v.variableCollectionId === c.id)
    );
    const lines = [];
    lines.push(`
      /**
       * Tailwind v4 Theme Variables
       * Generated by Figma Plugin
       * ${( new Date()).toISOString()}
       */
      @import "tailwindcss";

      @theme {
    `.trim());
    for (var i = 0; i < selectedIds.length; i++) {
      const collectionId = selectedIds[i];
      const collection = nonEmptyCollections.find((c) => c.id === collectionId);
      if (!collection)
        continue;
      const collectionName = collection.name || "Unnamed Collection";
      lines.push(`  /* ${collectionName} */`);
      const varsInCollection = allVariables.filter((v) => v.variableCollectionId === collectionId);
      for (var j = 0; j < varsInCollection.length; j++) {
        const variable = varsInCollection[j];
        const key = variable.name ? variable.name.replace(/\//g, "-").replace(/\s+/g, "-").toLowerCase() : "unnamed";
        const varName = variable.resolvedType === "COLOR" ? "--color-" + key : "--" + key;
        const modeIds = Object.keys(variable.valuesByMode || {});
        const val = modeIds.length > 0 ? variable.valuesByMode[modeIds[0]] : null;
        if (val && typeof val === "object" && val.type === "VARIABLE_ALIAS") {
          const aliasVar = allVariables.find((v) => v.id === val.id);
          const aliasName = aliasVar && aliasVar.name ? aliasVar.name.replace(/\//g, "-").replace(/\s+/g, "-").toLowerCase() : "alias";
          const aliasPrefix = aliasVar && aliasVar.resolvedType === "COLOR" ? "color-" : "";
          lines.push("  " + varName + ": var(--" + aliasPrefix + aliasName + ");");
        } else if (variable.resolvedType === "COLOR" && val && val.r !== void 0) {
          const r = Math.round(val.r * 255).toString(16).padStart(2, "0");
          const g = Math.round(val.g * 255).toString(16).padStart(2, "0");
          const b = Math.round(val.b * 255).toString(16).padStart(2, "0");
          const a = val.a !== void 0 ? val.a : 1;
          const hex = a === 1 ? "#" + r + g + b : "#" + r + g + b + Math.round(a * 255).toString(16).padStart(2, "0");
          lines.push("  " + varName + ": " + hex + ";");
        } else if (variable.resolvedType === "FLOAT") {
          const px = parseFloat(val);
          if (variable.name.toLowerCase().includes("weight")) {
            lines.push("  " + varName + ": " + px + ";");
          } else {
            const rem = px / 16;
            const value = rem === 0 ? "0rem" : rem.toFixed(4).replace(/\.0+$/, "").replace(/0+$/, "") + "rem";
            lines.push("  " + varName + ": " + value + ";");
          }
        } else {
          lines.push("  " + varName + ": " + val + ";");
        }
      }
      lines.push("");
    }
    lines.push("}");
    figma.ui.postMessage({ type: "download-css", content: lines.join("\n") });
  }
  if (msg.type === "export-json") {
    const selectedIds = msg.selected || [];
    const collections = await figma.variables.getLocalVariableCollectionsAsync();
    const variables = await figma.variables.getLocalVariablesAsync();
    const nonEmptyCollections = collections.filter(
      (c) => variables.some((v) => v.variableCollectionId === c.id)
    );
    let filteredCollections = nonEmptyCollections;
    let filteredVariables = variables;
    if (Array.isArray(selectedIds) && selectedIds.length > 0) {
      filteredCollections = nonEmptyCollections.filter((c) => selectedIds.includes(c.id));
      filteredVariables = variables.filter((v) => selectedIds.includes(v.variableCollectionId));
    }
    const data = {
      collections: filteredCollections.map((c) => ({
        id: c.id,
        name: c.name,
        defaultModeId: c.defaultModeId,
        modes: c.modes
      })),
      variables: filteredVariables.map((v) => ({
        id: v.id,
        name: v.name,
        resolvedType: v.resolvedType,
        variableCollectionId: v.variableCollectionId,
        valuesByMode: v.valuesByMode,
        scopes: v.scopes,
        // <-- include scopes
        codeSyntax: v.codeSyntax,
        // <-- include codeSyntax
        description: v.description,
        // <-- include description if available
        remote: v.remote,
        // <-- include remote if available
        key: v.key
        // <-- include key if available
        // Add any other properties you want to preserve
      }))
    };
    figma.ui.postMessage({ type: "download-json", content: JSON.stringify(data, null, 2) });
  }
  if (msg.type === "import-json") {
    try {
      const json = JSON.parse(msg.content);
      if (!json || !Array.isArray(json.collections) || !Array.isArray(json.variables)) {
        figma.notify("Invalid JSON: missing collections or variables array.");
        figma.ui.postMessage({ type: "import-feedback", message: "Invalid JSON: missing collections or variables array.", error: true });
        return;
      }
      if (!figma.variables || typeof figma.variables.createVariableCollection !== "function") {
        figma.notify("Figma Variables API not available in this context.");
        figma.ui.postMessage({ type: "import-feedback", message: "Figma Variables API not available in this context.", error: true });
        return;
      }
      const existingCollections = await figma.variables.getLocalVariableCollectionsAsync();
      const collectionMap = {};
      const modeIdMap = {};
      const generateUniqueName = (name) => {
        let newName = name;
        let count = 1;
        while (existingCollections.some((c) => c.name === newName)) {
          newName = `${name}-${count++}`;
        }
        return newName;
      };
      for (var i = 0; i < json.collections.length; i++) {
        const col = json.collections[i];
        if (!col.name)
          continue;
        const newCol = figma.variables.createVariableCollection(generateUniqueName(col.name));
        collectionMap[col.id] = newCol;
        const map = {};
        for (var k = 0; k < col.modes.length; k++) {
          const oldMode = col.modes[k];
          let newModeId;
          if (k === 0) {
            const defaultMode = newCol.modes[0];
            if (defaultMode) {
              newModeId = defaultMode.modeId;
              try {
                newCol.renameMode(newModeId, oldMode.name);
              } catch (e) {
                console.warn("Failed to rename mode", oldMode.name, e);
              }
            }
          } else {
            try {
              newModeId = newCol.addMode(oldMode.name);
            } catch (e) {
              console.warn("Failed to add mode", oldMode.name, e);
            }
          }
          if (newModeId) {
            map[oldMode.modeId] = newModeId;
          }
        }
        modeIdMap[col.id] = map;
      }
      const allExistingVars = await figma.variables.getLocalVariablesAsync();
      const variableMap = {};
      for (const v of json.variables) {
        const collection = collectionMap[v.variableCollectionId];
        if (!collection || !v.name)
          continue;
        const already = allExistingVars.find(
          (x) => x.name === v.name && x.variableCollectionId === collection.id
        );
        let newVar;
        if (already) {
          newVar = already;
        } else {
          newVar = figma.variables.createVariable(v.name, collection, v.resolvedType);
          if (v.scopes)
            try {
              newVar.scopes = v.scopes;
            } catch (e) {
            }
          if (v.description)
            try {
              newVar.description = v.description;
            } catch (e) {
            }
          if (v.remote !== void 0)
            try {
              newVar.remote = v.remote;
            } catch (e) {
            }
          if (v.key)
            try {
              newVar.key = v.key;
            } catch (e) {
            }
          if (v.codeSyntax && typeof v.codeSyntax === "object") {
            for (const platform of ["WEB", "ANDROID", "iOS"]) {
              if (v.codeSyntax[platform] && typeof v.codeSyntax[platform] === "string") {
                try {
                  newVar.setVariableCodeSyntax(platform, v.codeSyntax[platform]);
                } catch (err) {
                  console.warn("Failed to set codeSyntax", platform, v.name, err);
                }
              }
            }
          }
        }
        variableMap[v.id] = newVar;
      }
      for (const v of json.variables) {
        const newVar = variableMap[v.id];
        const collection = collectionMap[v.variableCollectionId];
        if (!collection || !newVar)
          continue;
        const valueMap = v.valuesByMode || {};
        for (const oldModeId of Object.keys(valueMap)) {
          const newModeId = modeIdMap[v.variableCollectionId] && modeIdMap[v.variableCollectionId][oldModeId];
          if (!newModeId)
            continue;
          let val = valueMap[oldModeId];
          if (val && val.type === "VARIABLE_ALIAS" && val.id && variableMap[val.id]) {
            val = Object.assign({}, val);
            val.id = variableMap[val.id].id;
          }
          try {
            newVar.setValueForMode(newModeId, val);
          } catch (e) {
            console.warn("Failed to set value for", newVar.name, e);
          }
        }
      }
      figma.notify("Figma variables imported successfully.");
      figma.ui.postMessage({ type: "import-feedback", message: "Figma variables imported successfully.", error: false });
      figma.ui.postMessage({ type: "refresh-collections" });
      figma.ui.postMessage({ type: "loading", loading: false });
    } catch (e) {
      console.error(e);
      figma.notify("Failed to import JSON. " + (e && e.message ? e.message : ""));
      figma.ui.postMessage({ type: "import-feedback", message: "Failed to import JSON. " + (e && e.message ? e.message : ""), error: true });
      figma.ui.postMessage({ type: "loading", loading: false });
    }
  }
};
