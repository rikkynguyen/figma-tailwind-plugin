figma.showUI(__html__, { width: 360, height: 0 });

figma.ui.onmessage = async function (msg) {
  if (msg.type === "resize") {
    figma.ui.resize(msg.width, msg.height);
  }

  if (msg.type === 'export') {
    const selectedIds = msg.selected;
    const collections = await figma.variables.getLocalVariableCollectionsAsync();
    const allVariables = await figma.variables.getLocalVariablesAsync();

    const selectedCollections = collections.filter(c => selectedIds.includes(c.id));
    const selectedVars = allVariables.filter(v => selectedIds.includes(v.variableCollectionId));

    const tokensByCollection = {};

    for (const collection of selectedCollections) {
      const collectionName = collection.name || "Unnamed";
      tokensByCollection[collectionName] = {};

      const collectionVars = selectedVars.filter(v => v.variableCollectionId === collection.id);

      for (const variable of collectionVars) {
        const originalName = variable.name;
        const key = originalName.replace(/\//g, '-').replace(/\s+/g, '-').toLowerCase();

        let group = "custom";
        if (variable.resolvedType === 'COLOR') {
          group = "color";
        } else if (variable.resolvedType === 'FLOAT') {
          group = collectionName.toLowerCase().includes("typography") ? "text" : "spacing";
        }

        const modeIds = Object.keys(variable.valuesByMode);
        const val = modeIds.length > 0 ? variable.valuesByMode[modeIds[0]] : null;

        if (!tokensByCollection[collectionName][group]) {
          tokensByCollection[collectionName][group] = [];
        }

        tokensByCollection[collectionName][group].push({
          id: variable.id,
          name: originalName,
          key: key,
          group: group,
          resolvedType: variable.resolvedType,
          isAlias: val && typeof val === 'object' && val.type === 'VARIABLE_ALIAS',
          rawValue: val
        });
      }
    }

    const lines = [];

    lines.push(`
      /**
       * Tailwind v4 Theme Variables
       * Generated by Figma Plugin
       * ${new Date().toISOString()}
       */
      @import "tailwindcss";

      @theme {
    `.trim());

    for (const collectionName in tokensByCollection) {
      const groups = tokensByCollection[collectionName];

      for (const groupName in groups) {
        lines.push(`  /* Group: ${groupName} (${collectionName}) */`);

        const items = groups[groupName];

        for (const token of items) {
          const varKey = token.name.replace(/\//g, '-').replace(/\s+/g, '-').toLowerCase();
          const varName = token.resolvedType === "COLOR" ? `--color-${varKey}` : `--${varKey}`;


          if (token.isAlias) {
            const aliasVar = allVariables.find(v => v.id === token.rawValue.id);
            const aliasName = aliasVar
              ? aliasVar.name.replace(/\//g, '-').replace(/\s+/g, '-').toLowerCase()
              : "alias";
            const aliasPrefix = aliasVar && aliasVar.resolvedType === "COLOR" ? "color-" : "";
            lines.push(`  ${varName}: var(--${aliasPrefix}${aliasName});`);
          } else if (token.resolvedType === 'COLOR') {
            const val = token.rawValue;
            if (val && val.r !== undefined) {
              const r = Math.round(val.r * 255).toString(16).padStart(2, '0');
              const g = Math.round(val.g * 255).toString(16).padStart(2, '0');
              const b = Math.round(val.b * 255).toString(16).padStart(2, '0');
              const a = val.a !== undefined ? val.a : 1;
              const hex = a === 1 ? `#${r}${g}${b}` : `#${r}${g}${b}${Math.round(a * 255).toString(16).padStart(2, '0')}`;
              lines.push(`  ${varName}: ${hex};`);
            }
          } else if (token.resolvedType === 'FLOAT') {
            const raw = token.rawValue;
            const isFontWeight = token.name.toLowerCase().includes("weight");
            if (typeof raw === 'number' || (typeof raw === 'string' && /^\d+(\.\d+)?$/.test(raw))) {
              const px = parseFloat(raw);
              if (isFontWeight) {
                lines.push(`  ${varName}: ${px};`);
              } else {
                const rem = px / 16;
                const value = rem === 0 ? '0rem' : rem.toFixed(4).replace(/\.0+$/, '').replace(/0+$/, '') + 'rem';
                lines.push(`  ${varName}: ${value};`);
              }
            } else {
              lines.push(`  ${varName}: ${token.rawValue};`);
            }
          } else {
            lines.push(`  ${varName}: ${token.rawValue};`);
          }
        }

        lines.push(""); // blank line between groups
      }

      lines.push(""); // blank line between collections
    }

    lines.push("}");

    const cssContent = lines.join("\n");

    figma.ui.postMessage({
      type: "download-css",
      css: cssContent
    });
  } else {
    const collections = await figma.variables.getLocalVariableCollectionsAsync();
    const formatted = collections.map(col => ({
      id: col.id,
      name: col.name || "(Unnamed Collection)"
    }));
    figma.ui.postMessage({ collections: formatted });
  }
};

(async function () {
  const collections = await figma.variables.getLocalVariableCollectionsAsync();
  const formatted = collections.map(col => ({
    id: col.id,
    name: col.name || "(Unnamed Collection)"
  }));
  figma.ui.postMessage({ collections: formatted });
})();