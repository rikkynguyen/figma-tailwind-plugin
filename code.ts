import { presetData } from './src/preset.js';

// Debug: Log Figma plugin environment and variables API
figma.showUI(__html__, { width: 420, height: 600 });

figma.ui.onmessage = async function (msg) {
  if (msg.type === "resize") {
    figma.ui.resize(msg.width, msg.height);
  }

  if (msg.type === "get-collections") {
    // Always fetch the latest collections and variables
    const collections = await figma.variables.getLocalVariableCollectionsAsync();
    const variables = await figma.variables.getLocalVariablesAsync();

    // Filter out collections with no variables
    const nonEmptyCollections = collections.filter(c =>
      variables.some(v => v.variableCollectionId === c.id)
    );

    figma.ui.postMessage({
      type: "collections",
      collections: nonEmptyCollections.map(c => ({
        id: c.id,
        name: c.name || "(Unnamed)",
        defaultModeId: c.defaultModeId,
        modes: c.modes
      })),
      variables: variables // send variables if needed for UI
    });
  }

  if (msg.type === "export-css") {
    const selectedIds = msg.selected;
    const allCollections = await figma.variables.getLocalVariableCollectionsAsync();
    const allVariables = await figma.variables.getLocalVariablesAsync();

    // Filter out collections with no variables
    const nonEmptyCollections = allCollections.filter(c =>
      allVariables.some(v => v.variableCollectionId === c.id)
    );

    const lines = [];
    lines.push(`
      /**
       * Tailwind v4 Theme Variables
       * Generated by Figma Plugin
       * ${new Date().toISOString()}
       */
      @import "tailwindcss";

      @theme {
    `.trim());

    for (var i = 0; i < selectedIds.length; i++) {
      const collectionId = selectedIds[i];
      const collection = nonEmptyCollections.find(c => c.id === collectionId);
      if (!collection) continue; // Skip empty collections

      const collectionName = collection.name || "Unnamed Collection";
      lines.push(`  /* ${collectionName} */`);

      const varsInCollection = allVariables.filter(v => v.variableCollectionId === collectionId);

      for (var j = 0; j < varsInCollection.length; j++) {
        const variable = varsInCollection[j];
        const key = variable.name ? variable.name.replace(/\//g, "-").replace(/\s+/g, "-").toLowerCase() : "unnamed";
        const varName = variable.resolvedType === "COLOR" ? "--color-" + key : "--" + key;

        const modeIds = Object.keys(variable.valuesByMode || {});
        const val = modeIds.length > 0 ? variable.valuesByMode[modeIds[0]] : null;

        if (val && typeof val === "object" && val.type === "VARIABLE_ALIAS") {
          const aliasVar = allVariables.find(v => v.id === val.id);
          const aliasName = aliasVar && aliasVar.name
            ? aliasVar.name.replace(/\//g, "-").replace(/\s+/g, "-").toLowerCase()
            : "alias";
          const aliasPrefix = aliasVar && aliasVar.resolvedType === "COLOR" ? "color-" : "";
          lines.push("  " + varName + ": var(--" + aliasPrefix + aliasName + ");");
        } else if (variable.resolvedType === "COLOR" && val && val.r !== undefined) {
          const r = Math.round(val.r * 255).toString(16).padStart(2, "0");
          const g = Math.round(val.g * 255).toString(16).padStart(2, "0");
          const b = Math.round(val.b * 255).toString(16).padStart(2, "0");
          const a = val.a !== undefined ? val.a : 1;
          const hex = a === 1 ? "#" + r + g + b : "#" + r + g + b + Math.round(a * 255).toString(16).padStart(2, "0");
          lines.push("  " + varName + ": " + hex + ";");
        } else if (variable.resolvedType === "FLOAT") {
          const px = parseFloat(val);
          if (variable.name.toLowerCase().includes("weight")) {
            lines.push("  " + varName + ": " + px + ";");
          } else {
            const rem = px / 16;
            const value = rem === 0 ? "0rem" : rem.toFixed(4).replace(/\.0+$/, "").replace(/0+$/, "") + "rem";
            lines.push("  " + varName + ": " + value + ";");
          }
        } else {
          lines.push("  " + varName + ": " + val + ";");
        }
      }

      lines.push(""); // blank line after each collection
    }

    lines.push("}");

    figma.ui.postMessage({ type: "download-css", content: lines.join("\n") });
  }

  if (msg.type === "export-json") {
    const selectedIds = msg.selected || [];
    const collections = await figma.variables.getLocalVariableCollectionsAsync();
    const variables = await figma.variables.getLocalVariablesAsync();

    // Filter out collections with no variables
    const nonEmptyCollections = collections.filter(c =>
      variables.some(v => v.variableCollectionId === c.id)
    );
    let filteredCollections = nonEmptyCollections;
    let filteredVariables = variables;
    if (Array.isArray(selectedIds) && selectedIds.length > 0) {
      filteredCollections = nonEmptyCollections.filter(c => selectedIds.includes(c.id));
      filteredVariables = variables.filter(v => selectedIds.includes(v.variableCollectionId));
    }

    const data = {
      collections: filteredCollections.map(c => ({
        id: c.id,
        name: c.name,
        defaultModeId: c.defaultModeId,
        modes: c.modes
      })),
      variables: filteredVariables.map(v => ({
        id: v.id,
        name: v.name,
        resolvedType: v.resolvedType,
        variableCollectionId: v.variableCollectionId,
        valuesByMode: v.valuesByMode,
        scopes: v.scopes,         // <-- include scopes
        codeSyntax: v.codeSyntax, // <-- include codeSyntax
        description: v.description, // <-- include description if available
        remote: v.remote,           // <-- include remote if available
        key: v.key                  // <-- include key if available
        // Add any other properties you want to preserve
      }))
    };

    figma.ui.postMessage({ type: "download-json", content: JSON.stringify(data, null, 2) });
  }

  async function applyCollectionsAndVariables(data: any) {
    const existingCollections = await figma.variables.getLocalVariableCollectionsAsync();
    const allExistingVars = await figma.variables.getLocalVariablesAsync();
    const collectionMap: Record<string, VariableCollection> = {};
    const modeIdMap: Record<string, Record<string, string>> = {};
    const variableMap: Record<string, Variable> = {};

    // Unique collection naming
    function generateUniqueName(name: string): string {
      let newName = name;
      let count = 1;
      while (existingCollections.some(function (c) { return c.name === newName; })) {
        newName = name + "-" + (count++);
      }
      return newName;
    }

    // Create collections
    for (var i = 0; i < data.collections.length; i++) {
      var col = data.collections[i];
      if (!col.name) continue;

      var newCol = figma.variables.createVariableCollection(generateUniqueName(col.name));
      collectionMap[col.id] = newCol;

      var map: Record<string, string> = {};
      for (var k = 0; k < col.modes.length; k++) {
        var oldMode = col.modes[k];
        var newModeId: string | undefined;

        if (k === 0) {
          var defaultMode = newCol.modes[0];
          if (defaultMode) {
            newModeId = defaultMode.modeId;
            try {
              newCol.renameMode(newModeId, oldMode.name);
            } catch (e) {
              console.warn("⚠️ Failed to rename mode:", oldMode.name, e);
            }
          }
        } else {
          try {
            newModeId = newCol.addMode(oldMode.name);
          } catch (e) {
            figma.notify("⚠️ Cannot add mode '" + oldMode.name + "'. Try a blank file or Figma Professional plan.");
            console.warn("❌ Failed to add mode", oldMode.name, e);
          }
        }

        if (newModeId) {
          map[oldMode.modeId] = newModeId;
        }
      }

      modeIdMap[col.id] = map;
    }

    // Create variables
    for (var j = 0; j < data.variables.length; j++) {
      var v = data.variables[j];
      var collection = collectionMap[v.variableCollectionId];
      if (!collection || !v.name) continue;

      var already = allExistingVars.find(function (x) {
        return x.name === v.name && x.variableCollectionId === collection.id;
      });

      var newVar: Variable;
      if (already) {
        newVar = already;
      } else {
        newVar = figma.variables.createVariable(v.name, collection, v.resolvedType);

        if (v.scopes) try { newVar.scopes = v.scopes; } catch (e) {}
        if (v.description) try { newVar.description = v.description; } catch (e) {}
        if (typeof v.remote !== "undefined") try { newVar.remote = v.remote; } catch (e) {}
        if (v.key) try { newVar.key = v.key; } catch (e) {}

        if (typeof v.codeSyntax === "object") {
          var platforms = ["WEB", "ANDROID", "iOS"];
          for (var p = 0; p < platforms.length; p++) {
            var platform = platforms[p];
            if (v.codeSyntax[platform] && typeof v.codeSyntax[platform] === "string") {
              try {
                newVar.setVariableCodeSyntax(platform, v.codeSyntax[platform]);
              } catch (e) {
                console.warn("Failed to set codeSyntax for", v.name, platform, e);
              }
            }
          }
        }
      }

      variableMap[v.id] = newVar;
    }

    // Set variable values
    for (var j = 0; j < data.variables.length; j++) {
      var v = data.variables[j];
      var newVar = variableMap[v.id];
      var collection = collectionMap[v.variableCollectionId];
      if (!newVar || !collection) continue;

      var valueMap = v.valuesByMode || {};
      for (var key in valueMap) {
        var newModeId = modeIdMap[v.variableCollectionId] && modeIdMap[v.variableCollectionId][key];
        if (!newModeId) continue;

        var val = valueMap[key];
        if (val && val.type === "VARIABLE_ALIAS" && val.id && variableMap[val.id]) {
          val = {
            type: "VARIABLE_ALIAS",
            id: variableMap[val.id].id
          };
        }

        try {
          newVar.setValueForMode(newModeId, val);
        } catch (e) {
          console.warn("❌ Failed to set value for", newVar.name, e);
        }
      }
    }

    figma.ui.postMessage({ type: "refresh-collections" });
  }

  if (msg.type === "import-json") {
    try {
      var json = JSON.parse(msg.content);
      if (!json || !json.collections || !json.variables) throw new Error("Invalid JSON structure");

      await applyCollectionsAndVariables(json);

      figma.notify("✅ Figma variables imported successfully.");
      figma.ui.postMessage({ type: "import-feedback", message: "Import successful.", error: false });
      figma.ui.postMessage({ type: "loading", loading: false });
    } catch (e) {
      console.error("❌ Import error", e);
      figma.notify("Failed to import JSON.");
      figma.ui.postMessage({ type: "import-feedback", message: "Import failed: " + (e.message || ""), error: true });
      figma.ui.postMessage({ type: "loading", loading: false });
    }
    figma.ui.postMessage({ type: "refresh-collections" });
    figma.ui.postMessage({ type: "import-feedback", message: "Import completed", error: false });
  }

  if (msg.type === "generate-preset") {
    try {
      await applyCollectionsAndVariables(presetData);
      figma.notify("✅ Preset variables generated.");
    } catch (e) {
      figma.notify("❌ Failed to generate preset.");
      console.error(e);
    }

    figma.ui.postMessage({ type: "generate-feedback", message: "Variables generated successfully." });
    figma.ui.postMessage({ type: "refresh-collections" });
  }


};
