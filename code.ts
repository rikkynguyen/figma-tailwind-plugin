// Debug: Log Figma plugin environment and variables API
figma.showUI(__html__, { width: 420, height: 500 });

figma.ui.onmessage = async function (msg) {
  if (msg.type === "resize") {
    figma.ui.resize(msg.width, msg.height);
  }

  if (msg.type === "get-collections") {
    // Always fetch the latest collections and variables
    const collections = await figma.variables.getLocalVariableCollectionsAsync();
    const variables = await figma.variables.getLocalVariablesAsync();

    // Filter out collections with no variables
    const nonEmptyCollections = collections.filter(c =>
      variables.some(v => v.variableCollectionId === c.id)
    );

    figma.ui.postMessage({
      type: "collections",
      collections: nonEmptyCollections.map(c => ({
        id: c.id,
        name: c.name || "(Unnamed)",
        defaultModeId: c.defaultModeId,
        modes: c.modes
      })),
      variables: variables // send variables if needed for UI
    });
  }

  if (msg.type === "export-css") {
    const selectedIds = msg.selected;
    const allCollections = await figma.variables.getLocalVariableCollectionsAsync();
    const allVariables = await figma.variables.getLocalVariablesAsync();

    // Filter out collections with no variables
    const nonEmptyCollections = allCollections.filter(c =>
      allVariables.some(v => v.variableCollectionId === c.id)
    );

    const lines = [];
    lines.push(`
      /**
       * Tailwind v4 Theme Variables
       * Generated by Figma Plugin
       * ${new Date().toISOString()}
       */
      @import "tailwindcss";

      @theme {
    `.trim());

    for (var i = 0; i < selectedIds.length; i++) {
      const collectionId = selectedIds[i];
      const collection = nonEmptyCollections.find(c => c.id === collectionId);
      if (!collection) continue; // Skip empty collections

      const collectionName = collection.name || "Unnamed Collection";
      lines.push(`  /* ${collectionName} */`);

      const varsInCollection = allVariables.filter(v => v.variableCollectionId === collectionId);

      for (var j = 0; j < varsInCollection.length; j++) {
        const variable = varsInCollection[j];
        const key = variable.name ? variable.name.replace(/\//g, "-").replace(/\s+/g, "-").toLowerCase() : "unnamed";
        const varName = variable.resolvedType === "COLOR" ? "--color-" + key : "--" + key;

        const modeIds = Object.keys(variable.valuesByMode || {});
        const val = modeIds.length > 0 ? variable.valuesByMode[modeIds[0]] : null;

        if (val && typeof val === "object" && val.type === "VARIABLE_ALIAS") {
          const aliasVar = allVariables.find(v => v.id === val.id);
          const aliasName = aliasVar && aliasVar.name
            ? aliasVar.name.replace(/\//g, "-").replace(/\s+/g, "-").toLowerCase()
            : "alias";
          const aliasPrefix = aliasVar && aliasVar.resolvedType === "COLOR" ? "color-" : "";
          lines.push("  " + varName + ": var(--" + aliasPrefix + aliasName + ");");
        } else if (variable.resolvedType === "COLOR" && val && val.r !== undefined) {
          const r = Math.round(val.r * 255).toString(16).padStart(2, "0");
          const g = Math.round(val.g * 255).toString(16).padStart(2, "0");
          const b = Math.round(val.b * 255).toString(16).padStart(2, "0");
          const a = val.a !== undefined ? val.a : 1;
          const hex = a === 1 ? "#" + r + g + b : "#" + r + g + b + Math.round(a * 255).toString(16).padStart(2, "0");
          lines.push("  " + varName + ": " + hex + ";");
        } else if (variable.resolvedType === "FLOAT") {
          const px = parseFloat(val);
          if (variable.name.toLowerCase().includes("weight")) {
            lines.push("  " + varName + ": " + px + ";");
          } else {
            const rem = px / 16;
            const value = rem === 0 ? "0rem" : rem.toFixed(4).replace(/\.0+$/, "").replace(/0+$/, "") + "rem";
            lines.push("  " + varName + ": " + value + ";");
          }
        } else {
          lines.push("  " + varName + ": " + val + ";");
        }
      }

      lines.push(""); // blank line after each collection
    }

    lines.push("}");

    figma.ui.postMessage({ type: "download-css", content: lines.join("\n") });
  }

  if (msg.type === "export-json") {
    const selectedIds = msg.selected || [];
    const collections = await figma.variables.getLocalVariableCollectionsAsync();
    const variables = await figma.variables.getLocalVariablesAsync();

    // Filter out collections with no variables
    const nonEmptyCollections = collections.filter(c =>
      variables.some(v => v.variableCollectionId === c.id)
    );
    let filteredCollections = nonEmptyCollections;
    let filteredVariables = variables;
    if (Array.isArray(selectedIds) && selectedIds.length > 0) {
      filteredCollections = nonEmptyCollections.filter(c => selectedIds.includes(c.id));
      filteredVariables = variables.filter(v => selectedIds.includes(v.variableCollectionId));
    }

    const data = {
      collections: filteredCollections.map(c => ({
        id: c.id,
        name: c.name,
        defaultModeId: c.defaultModeId,
        modes: c.modes
      })),
      // variables: filteredVariables.map(v => {
      //   let codeSyntax = null;
      //   if (v.codeSyntax && typeof v.codeSyntax === "object") {
      //     const platforms = Object.keys(v.codeSyntax);
      //     if (platforms.length > 0) {
      //       codeSyntax = {
      //         platform: platforms[0],
      //         syntax: v.codeSyntax[platforms[0]]
      //       };
      //     }
      //   }

      //   return {
      //     id: v.id,
      //     name: v.name,
      //     resolvedType: v.resolvedType,
      //     variableCollectionId: v.variableCollectionId,
      //     valuesByMode: v.valuesByMode,
      //     scopes: v.scopes,
      //     codeSyntax,
      //     description: v.description,
      //     remote: v.remote,
      //     key: v.key
      //   };
      // })
      variables: filteredVariables.map(v => ({
        id: v.id,
        name: v.name,
        resolvedType: v.resolvedType,
        variableCollectionId: v.variableCollectionId,
        valuesByMode: v.valuesByMode,
        scopes: v.scopes,         // <-- include scopes
        codeSyntax: v.codeSyntax, // <-- include codeSyntax
        description: v.description, // <-- include description if available
        remote: v.remote,           // <-- include remote if available
        key: v.key                  // <-- include key if available
        // Add any other properties you want to preserve
      }))
    };

    figma.ui.postMessage({ type: "download-json", content: JSON.stringify(data, null, 2) });
  }

  if (msg.type === "import-json") {
    try {
      const json = JSON.parse(msg.content);
      if (!json || !Array.isArray(json.collections) || !Array.isArray(json.variables)) {
        figma.notify("Invalid JSON: missing collections or variables array.");
        figma.ui.postMessage({ type: "import-feedback", message: "Invalid JSON: missing collections or variables array.", error: true });
        return;
      }

      if (!figma.variables || typeof figma.variables.createVariableCollection !== 'function') {
        figma.notify("Figma Variables API not available in this context.");
        figma.ui.postMessage({ type: "import-feedback", message: "Figma Variables API not available in this context.", error: true });
        return;
      }
      const existingCollections = await figma.variables.getLocalVariableCollectionsAsync();
      const collectionMap = {}; // old collection id -> new collection id
      const modeIdMap = {}; // old collection id -> { oldModeId: newModeId }

      for (var i = 0; i < json.collections.length; i++) {
        const col = json.collections[i];
        if (!col.name) continue;
        // Avoid duplicate collection names
        let newCol;
        const already = existingCollections.find(c => c.name === col.name);
        if (already) {
          newCol = already;
        } else {
          newCol = figma.variables.createVariableCollection(col.name);
        }
        collectionMap[col.id] = newCol.id;
        // Map old mode IDs to new mode IDs by order
        if (Array.isArray(col.modes) && Array.isArray(newCol.modes)) {
          const map = {};
          for (let k = 0; k < col.modes.length && k < newCol.modes.length; k++) {
            map[col.modes[k].modeId] = newCol.modes[k].modeId;
          }
          modeIdMap[col.id] = map;
        } else {
          modeIdMap[col.id] = {};
        }
      }


      // First pass: create all variables and store by old id
      const variableMap = {}; // old variable id -> new variable
      for (var j = 0; j < json.variables.length; j++) {
        const v = json.variables[j];
        const oldCollectionId = v.variableCollectionId;
        const collectionId = collectionMap[oldCollectionId];
        if (!collectionId || !v.name) continue;
        // Avoid duplicate variable names in the same collection
        const existingVars = await figma.variables.getLocalVariablesAsync();
        const alreadyVar = existingVars.find(x => x.name === v.name && x.variableCollectionId === collectionId);
        let newVar;

        if (alreadyVar) {
          newVar = alreadyVar;
        } else {
          newVar = figma.variables.createVariable(v.name, collectionId, v.resolvedType);
          // Restore extra details if available
          if (v.scopes && Array.isArray(v.scopes)) {
            try { newVar.scopes = v.scopes; } catch (e) {}
          }
          console.log("Raw codeSyntax for", v.name, JSON.stringify(v.codeSyntax));

          const rawSyntax = v.codeSyntax;
          if (typeof rawSyntax === "object" && rawSyntax !== null) {
            const platformKeys = Object.keys(rawSyntax);
            for (const key of platformKeys) {
              const platform = key.toUpperCase();
              const syntax = rawSyntax[key];

              // ✅ Validate
              const validPlatforms = ["WEB", "ANDROID", "IOS"];
              if (validPlatforms.includes(platform) && typeof syntax === "string") {
                console.log("🧪 Applying codeSyntax for", v.name, { platform, syntax });

                try {
                  newVar.setVariableCodeSyntax({
                    platform,  // ✅ plain assignment
                    syntax
                  });
                } catch (e) {
                  console.warn("❌ Failed to set codeSyntax for", v.name, e);
                }
              } else {
                console.warn("⚠️ Invalid codeSyntax entry for", v.name, key, syntax);
              }
            }
          }




          if (v.description) {
            try { newVar.description = v.description; } catch (e) {}
          }
          if (v.remote !== undefined) {
            try { newVar.remote = v.remote; } catch (e) {}
          }
          if (v.key) {
            try { newVar.key = v.key; } catch (e) {}
          }
        }

        variableMap[v.id] = newVar;
      }

      // Second pass: set values (including aliases)
      for (var j = 0; j < json.variables.length; j++) {
        const v = json.variables[j];
        const oldCollectionId = v.variableCollectionId;
        const collectionId = collectionMap[oldCollectionId];
        if (!collectionId || !v.name) continue;
        const newVar = variableMap[v.id];
        const modes = Object.keys(v.valuesByMode || {});
        for (var m = 0; m < modes.length; m++) {
          const oldModeId = modes[m];
          const newModeId = modeIdMap[oldCollectionId] && modeIdMap[oldCollectionId][oldModeId];
          if (newModeId) {
            let value = v.valuesByMode[oldModeId];
            // If value is a VARIABLE_ALIAS, remap the id
            if (value && typeof value === 'object' && value.type === 'VARIABLE_ALIAS' && value.id) {
              if (variableMap[value.id]) {
                value = Object.assign({}, value, { id: variableMap[value.id].id });
              } else {
                // If alias target not found, skip
                continue;
              }
            }
            newVar.setValueForMode(newModeId, value);
          }
        }
      }

      figma.notify("Figma variables imported successfully.");
      figma.ui.postMessage({ type: "import-feedback", message: "Figma variables imported successfully.", error: false });
      figma.ui.postMessage({ type: "refresh-collections" });
      figma.ui.postMessage({ type: "loading", loading: false });
    } catch (e) {
      console.error(e);
      figma.notify("Failed to import JSON. " + (e && e.message ? e.message : ""));
      figma.ui.postMessage({ type: "import-feedback", message: "Failed to import JSON. " + (e && e.message ? e.message : ""), error: true });
      figma.ui.postMessage({ type: "loading", loading: false });
    }
  }
};
