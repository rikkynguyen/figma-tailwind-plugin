figma.showUI(__html__, { width: 420, height: 500 });

figma.ui.onmessage = async function (msg) {
  if (msg.type === "resize") {
    figma.ui.resize(msg.width, msg.height);
  }

  if (msg.type === "get-collections") {
    const collections = await figma.variables.getLocalVariableCollectionsAsync();
    figma.ui.postMessage({
      type: "collections",
      collections: collections.map(c => ({
        id: c.id,
        name: c.name || "(Unnamed)",
        defaultModeId: c.defaultModeId,
        modes: c.modes
      }))
    });
  }

  if (msg.type === "export-css") {
  const selectedIds = msg.selected;
  const allCollections = await figma.variables.getLocalVariableCollectionsAsync();
  const allVariables = await figma.variables.getLocalVariablesAsync();

  const lines = [];

  lines.push(`
    /**
     * Tailwind v4 Theme Variables
     * Generated by Figma Plugin
     * ${new Date().toISOString()}
     */
    @import "tailwindcss";

    @theme {
  `.trim());

  for (var i = 0; i < selectedIds.length; i++) {
    const collectionId = selectedIds[i];
    const collection = allCollections.find(c => c.id === collectionId);
    const collectionName = collection ? collection.name : "Unnamed Collection";

    lines.push(`  /* ${collectionName} */`);

    const varsInCollection = allVariables.filter(v => v.variableCollectionId === collectionId);

    for (var j = 0; j < varsInCollection.length; j++) {
      const variable = varsInCollection[j];
      const key = variable.name ? variable.name.replace(/\//g, "-").replace(/\s+/g, "-").toLowerCase() : "unnamed";
      const varName = variable.resolvedType === "COLOR" ? "--color-" + key : "--" + key;

      const modeIds = Object.keys(variable.valuesByMode || {});
      const val = modeIds.length > 0 ? variable.valuesByMode[modeIds[0]] : null;

      if (val && typeof val === "object" && val.type === "VARIABLE_ALIAS") {
        const aliasVar = allVariables.find(v => v.id === val.id);
        const aliasName = aliasVar && aliasVar.name
          ? aliasVar.name.replace(/\//g, "-").replace(/\s+/g, "-").toLowerCase()
          : "alias";
        const aliasPrefix = aliasVar && aliasVar.resolvedType === "COLOR" ? "color-" : "";
        lines.push("  " + varName + ": var(--" + aliasPrefix + aliasName + ");");
      } else if (variable.resolvedType === "COLOR" && val && val.r !== undefined) {
        const r = Math.round(val.r * 255).toString(16).padStart(2, "0");
        const g = Math.round(val.g * 255).toString(16).padStart(2, "0");
        const b = Math.round(val.b * 255).toString(16).padStart(2, "0");
        const a = val.a !== undefined ? val.a : 1;
        const hex = a === 1 ? "#" + r + g + b : "#" + r + g + b + Math.round(a * 255).toString(16).padStart(2, "0");
        lines.push("  " + varName + ": " + hex + ";");
      } else if (variable.resolvedType === "FLOAT") {
        const px = parseFloat(val);
        if (variable.name.toLowerCase().includes("weight")) {
          lines.push("  " + varName + ": " + px + ";");
        } else {
          const rem = px / 16;
          const value = rem === 0 ? "0rem" : rem.toFixed(4).replace(/\.0+$/, "").replace(/0+$/, "") + "rem";
          lines.push("  " + varName + ": " + value + ";");
        }
      } else {
        lines.push("  " + varName + ": " + val + ";");
      }
    }

    lines.push(""); // blank line after each collection
  }

  lines.push("}");

  figma.ui.postMessage({ type: "download-css", content: lines.join("\n") });
}


  if (msg.type === "export-json") {
    const collections = await figma.variables.getLocalVariableCollectionsAsync();
    const variables = await figma.variables.getLocalVariablesAsync();
    const data = {
      collections: collections.map(function (c) {
        return {
          id: c.id,
          name: c.name,
          defaultModeId: c.defaultModeId,
          modes: c.modes
        };
      }),
      variables: variables.map(function (v) {
        return {
          id: v.id,
          name: v.name,
          resolvedType: v.resolvedType,
          variableCollectionId: v.variableCollectionId,
          valuesByMode: v.valuesByMode
        };
      })
    };
    figma.ui.postMessage({ type: "download-json", content: JSON.stringify(data, null, 2) });
  }

  if (msg.type === "import-json") {
    try {
      const json = JSON.parse(msg.content);
      const collectionMap = {};

      for (var i = 0; i < json.collections.length; i++) {
        const col = json.collections[i];
        const newCol = await figma.variables.createVariableCollectionAsync(col.name);
        collectionMap[col.id] = newCol.id;
      }

      for (var j = 0; j < json.variables.length; j++) {
        const v = json.variables[j];
        const collectionId = collectionMap[v.variableCollectionId];

        if (!collectionId) continue;

        const newVar = await figma.variables.createVariableAsync(v.name, collectionId, v.resolvedType);

        const modes = Object.keys(v.valuesByMode || {});
        for (var m = 0; m < modes.length; m++) {
          const modeId = modes[m];
          await newVar.setValueForMode(modeId, v.valuesByMode[modeId]);
        }
      }

      figma.notify("Figma variables imported successfully.");
    } catch (e) {
      console.error(e);
      figma.notify("Failed to import JSON.");
    }
  }
};
