import { presetData } from './preset.js';

// Debug: Log Figma plugin environment and variables API
figma.showUI(__html__, { width: 420, height: 600 });

figma.ui.onmessage = async function (msg) {
  if (msg.type === "resize") {
    figma.ui.resize(msg.width, msg.height);
  }

  if (msg.type === "get-collections") {
    // Always fetch the latest collections and variables
    const collections = await figma.variables.getLocalVariableCollectionsAsync();
    const variables = await figma.variables.getLocalVariablesAsync();

    // Filter out collections with no variables
    const nonEmptyCollections = collections.filter(c =>
      variables.some(v => v.variableCollectionId === c.id)
    );

    figma.ui.postMessage({
      type: "collections",
      collections: nonEmptyCollections.map(c => ({
        id: c.id,
        name: c.name || "(Unnamed)",
        defaultModeId: c.defaultModeId,
        modes: c.modes
      })),
      variables: variables // send variables if needed for UI
    });
  }

  if (msg.type === "export-css") {
    const selectedIds = msg.selected;
    const allCollections = await figma.variables.getLocalVariableCollectionsAsync();
    const allVariables = await figma.variables.getLocalVariablesAsync();

    // Filter out collections with no variables
    const nonEmptyCollections = allCollections.filter(c =>
      allVariables.some(v => v.variableCollectionId === c.id)
    );

    const lines = [];
    lines.push(`
      /**
       * Tailwind v4 Theme Variables
       * Generated by Figma Plugin
       * ${new Date().toISOString()}
       */
      @import "tailwindcss";

      @theme {
    `.trim());

    for (var i = 0; i < selectedIds.length; i++) {
      const collectionId = selectedIds[i];
      const collection = nonEmptyCollections.find(c => c.id === collectionId);
      if (!collection) continue; // Skip empty collections

      const collectionName = collection.name || "Unnamed Collection";
      lines.push(`  /* ${collectionName} */`);

      const varsInCollection = allVariables.filter(v => v.variableCollectionId === collectionId);

      for (var j = 0; j < varsInCollection.length; j++) {
        const variable = varsInCollection[j];
        const key = variable.name ? variable.name.replace(/\//g, "-").replace(/\s+/g, "-").toLowerCase() : "unnamed";
        const varName = variable.resolvedType === "COLOR" ? "--color-" + key : "--" + key;

        const modeIds = Object.keys(variable.valuesByMode || {});
        const val = modeIds.length > 0 ? variable.valuesByMode[modeIds[0]] : null;

        if (val && typeof val === "object" && val.type === "VARIABLE_ALIAS") {
          const aliasVar = allVariables.find(v => v.id === val.id);
          const aliasName = aliasVar && aliasVar.name
            ? aliasVar.name.replace(/\//g, "-").replace(/\s+/g, "-").toLowerCase()
            : "alias";
          const aliasPrefix = aliasVar && aliasVar.resolvedType === "COLOR" ? "color-" : "";
          lines.push("  " + varName + ": var(--" + aliasPrefix + aliasName + ");");
        } else if (variable.resolvedType === "COLOR" && val && val.r !== undefined) {
          const r = Math.round(val.r * 255).toString(16).padStart(2, "0");
          const g = Math.round(val.g * 255).toString(16).padStart(2, "0");
          const b = Math.round(val.b * 255).toString(16).padStart(2, "0");
          const a = val.a !== undefined ? val.a : 1;
          const hex = a === 1 ? "#" + r + g + b : "#" + r + g + b + Math.round(a * 255).toString(16).padStart(2, "0");
          lines.push("  " + varName + ": " + hex + ";");
        } else if (variable.resolvedType === "FLOAT") {
          const px = parseFloat(val);
          if (variable.name.toLowerCase().includes("weight")) {
            lines.push("  " + varName + ": " + px + ";");
          } else {
            const rem = px / 16;
            const value = rem === 0 ? "0rem" : rem.toFixed(4).replace(/\.0+$/, "").replace(/0+$/, "") + "rem";
            lines.push("  " + varName + ": " + value + ";");
          }
        } else {
          lines.push("  " + varName + ": " + val + ";");
        }
      }

      lines.push(""); // blank line after each collection
    }

    lines.push("}");

    figma.ui.postMessage({ type: "download-css", content: lines.join("\n") });
  }

  if (msg.type === "export-json") {
    const selectedIds = msg.selected || [];
    const collections = await figma.variables.getLocalVariableCollectionsAsync();
    const variables = await figma.variables.getLocalVariablesAsync();

    // Filter out collections with no variables
    const nonEmptyCollections = collections.filter(c =>
      variables.some(v => v.variableCollectionId === c.id)
    );
    let filteredCollections = nonEmptyCollections;
    let filteredVariables = variables;
    if (Array.isArray(selectedIds) && selectedIds.length > 0) {
      filteredCollections = nonEmptyCollections.filter(c => selectedIds.includes(c.id));
      filteredVariables = variables.filter(v => selectedIds.includes(v.variableCollectionId));
    }

    const data = {
      collections: filteredCollections.map(c => ({
        id: c.id,
        name: c.name,
        defaultModeId: c.defaultModeId,
        modes: c.modes
      })),
      variables: filteredVariables.map(v => ({
        id: v.id,
        name: v.name,
        resolvedType: v.resolvedType,
        variableCollectionId: v.variableCollectionId,
        valuesByMode: v.valuesByMode,
        scopes: v.scopes,         // <-- include scopes
        codeSyntax: v.codeSyntax, // <-- include codeSyntax
        description: v.description, // <-- include description if available
        remote: v.remote,           // <-- include remote if available
        key: v.key                  // <-- include key if available
        // Add any other properties you want to preserve
      }))
    };

    figma.ui.postMessage({ type: "download-json", content: JSON.stringify(data, null, 2) });
  }

  if (msg.type === "import-json") {
    try {
      const json = JSON.parse(msg.content);
      if (!json || !Array.isArray(json.collections) || !Array.isArray(json.variables)) {
        figma.notify("Invalid JSON: missing collections or variables array.");
        figma.ui.postMessage({ type: "import-feedback", message: "Invalid JSON: missing collections or variables array.", error: true });
        return;
      }

      if (!figma.variables || typeof figma.variables.createVariableCollection !== 'function') {
        figma.notify("Figma Variables API not available in this context.");
        figma.ui.postMessage({ type: "import-feedback", message: "Figma Variables API not available in this context.", error: true });
        return;
      }

      const existingCollections = await figma.variables.getLocalVariableCollectionsAsync();
      const collectionMap: Record<string, VariableCollection> = {};
      const modeIdMap: Record<string, Record<string, string>> = {};

      // Helper to avoid duplicate names
      const generateUniqueName = (name: string): string => {
        let newName = name;
        let count = 1;
        while (existingCollections.some(c => c.name === newName)) {
          newName = `${name}-${count++}`;
        }
        return newName;
      };

      for (var i = 0; i < json.collections.length; i++) {
        const col = json.collections[i];
        if (!col.name) continue;

        const newCol = figma.variables.createVariableCollection(generateUniqueName(col.name));
        collectionMap[col.id] = newCol;

        const map: Record<string, string> = {};

        for (var k = 0; k < col.modes.length; k++) {
          const oldMode = col.modes[k];
          let newModeId: string | undefined;

          if (k === 0) {
            const defaultMode = newCol.modes[0];
            if (defaultMode) {
              newModeId = defaultMode.modeId;
              try {
                newCol.renameMode(newModeId, oldMode.name);
              } catch (e) {
                console.warn("Failed to rename mode", oldMode.name, e);
              }
            }
          } else {
            try {
              newModeId = newCol.addMode(oldMode.name);
            } catch (e) {
              console.warn("❌ Failed to add mode", oldMode.name, e);

              figma.notify("Cannot add more than one mode. Try using a blank file or upgrade to Figma Professional.");
              figma.ui.postMessage({
                type: "import-feedback",
                message: "Cannot add mode '" + oldMode.name + "'. This may be due to limitations in Figma's free plan or importing into a non-blank file.",
                error: true
              });
            }
          }

          if (newModeId) {
            map[oldMode.modeId] = newModeId;
          }
        }

        modeIdMap[col.id] = map;
      }

      const allExistingVars = await figma.variables.getLocalVariablesAsync();
      const variableMap: Record<string, Variable> = {};

      for (const v of json.variables) {
        const collection = collectionMap[v.variableCollectionId];
        if (!collection || !v.name) continue;

        const already = allExistingVars.find(
          x => x.name === v.name && x.variableCollectionId === collection.id
        );

        let newVar: Variable;

        if (already) {
          newVar = already;
        } else {
          newVar = figma.variables.createVariable(v.name, collection, v.resolvedType as VariableResolvedType);

          // Extra props
          if (v.scopes) try { newVar.scopes = v.scopes; } catch (e) {}
          if (v.description) try { newVar.description = v.description; } catch (e) {}
          if (v.remote !== undefined) try { newVar.remote = v.remote; } catch (e) {}
          if (v.key) try { newVar.key = v.key; } catch (e) {}

          // Code syntax handling
          if (v.codeSyntax && typeof v.codeSyntax === 'object') {
            for (const platform of ['WEB', 'ANDROID', 'iOS'] as const) {
              if (v.codeSyntax[platform] && typeof v.codeSyntax[platform] === 'string') {
                try {
                  newVar.setVariableCodeSyntax(platform, v.codeSyntax[platform]);
                } catch (err) {
                  console.warn("Failed to set codeSyntax", platform, v.name, err);
                }
              }
            }
          }
        }

        variableMap[v.id] = newVar;
      }

      // Second pass: set values
      for (const v of json.variables) {
        const newVar = variableMap[v.id];
        const collection = collectionMap[v.variableCollectionId];
        if (!collection || !newVar) continue;

        const valueMap = v.valuesByMode || {};
        for (const oldModeId of Object.keys(valueMap)) {
          const newModeId = modeIdMap[v.variableCollectionId][oldModeId];
          if (!newModeId) continue;

          let val = valueMap[oldModeId];

          // ✅ SMART ALIAS REMAPPING
          if (val && val.type === "VARIABLE_ALIAS" && val.id) {
            const targetVar = variableMap[val.id];
            if (targetVar) {
              val = {
                type: "VARIABLE_ALIAS",
                id: targetVar.id
              };
            } else {
              console.warn("Alias target not found:", val.id);
              continue; // skip broken alias
            }
          }

          try {
            newVar.setValueForMode(newModeId, val);
          } catch (e) {
            console.warn("❌ Failed to set value", newVar.name, "in mode", newModeId, e);
          }
        }
      }


      figma.notify("Figma variables imported successfully.");
      figma.ui.postMessage({ type: "import-feedback", message: "Figma variables imported successfully.", error: false });
      figma.ui.postMessage({ type: "refresh-collections" });
      figma.ui.postMessage({ type: "loading", loading: false });
    } catch (e) {
      console.error(e);
      figma.notify("Failed to import JSON. " + (e && e.message ? e.message : ""));
      figma.ui.postMessage({ type: "import-feedback", message: "Failed to import JSON. " + (e && e.message ? e.message : ""), error: true });
      figma.ui.postMessage({ type: "loading", loading: false });
    }
  }

  if (msg.type === "generate-preset") {
    const data = presetData;
    const existingCollections = await figma.variables.getLocalVariableCollectionsAsync();
    const collectionMap: Record<string, VariableCollection> = {};
    const modeIdMap: Record<string, Record<string, string>> = {};

    const generateUniqueName = (name: string): string => {
      let newName = name;
      let count = 1;
      while (existingCollections.some(c => c.name === newName)) {
        newName = `${name}-${count++}`;
      }
      return newName;
    };

    for (const col of data.collections) {
      if (!col.name) continue;

      const newCol = figma.variables.createVariableCollection(generateUniqueName(col.name));
      collectionMap[col.id] = newCol;

      const map: Record<string, string> = {};

      for (let k = 0; k < col.modes.length; k++) {
        const oldMode = col.modes[k];
        let newModeId: string | undefined;

        if (k === 0) {
          const defaultMode = newCol.modes[0];
          if (defaultMode) {
            newModeId = defaultMode.modeId;
            try {
              newCol.renameMode(newModeId, oldMode.name);
            } catch (e) {
              console.warn("Failed to rename mode", oldMode.name, e);
            }
          }
        } else {
          try {
            newModeId = newCol.addMode(oldMode.name);
          } catch (e) {
            figma.notify(`⚠️ Cannot add mode "${oldMode.name}" — incremental mode or free plan limitation.`);
            console.warn("Cannot add mode", oldMode.name, e);
          }
        }

        if (newModeId) {
          map[oldMode.modeId] = newModeId;
        }
      }

      modeIdMap[col.id] = map;
    }

    const variableMap: Record<string, Variable> = {};
    const allExistingVars = await figma.variables.getLocalVariablesAsync();

    for (const v of data.variables) {
      const collection = collectionMap[v.variableCollectionId];
      if (!collection || !v.name) continue;

      const already = allExistingVars.find(x => x.name === v.name && x.variableCollectionId === collection.id);
      let newVar: Variable;

      if (already) {
        newVar = already;
      } else {
        newVar = figma.variables.createVariable(v.name, collection, v.resolvedType as VariableResolvedType);
        if (v.scopes) try { newVar.scopes = v.scopes; } catch (e) {}
        if (v.description) try { newVar.description = v.description; } catch (e) {}
        if (v.remote !== undefined) try { newVar.remote = v.remote; } catch (e) {}
        if (v.key) try { newVar.key = v.key; } catch (e) {}

        // codeSyntax support
        if (v.codeSyntax && typeof v.codeSyntax === 'object') {
          for (const platform of ['WEB', 'ANDROID', 'iOS'] as const) {
            if (v.codeSyntax[platform]) {
              try {
                newVar.setVariableCodeSyntax(platform, v.codeSyntax[platform]);
              } catch (e) {
                console.warn("Failed to set codeSyntax", platform, v.name, e);
              }
            }
          }
        }
      }

      variableMap[v.id] = newVar;
    }

    // Set values
    for (const v of data.variables) {
      const newVar = variableMap[v.id];
      const collection = collectionMap[v.variableCollectionId];
      if (!collection || !newVar) continue;

      const valueMap = v.valuesByMode || {};
      for (const oldModeId in valueMap) {
        const newModeId = modeIdMap[v.variableCollectionId] && modeIdMap[v.variableCollectionId][oldModeId];
        if (!newModeId) continue;

        let val = valueMap[oldModeId];
        if (val && val.type === "VARIABLE_ALIAS" && val.id && variableMap[val.id]) {
          val = Object.assign({}, val, { id: variableMap[val.id].id });
        }

        try {
          newVar.setValueForMode(newModeId, val);
        } catch (e) {
          console.warn("Failed to set value", newVar.name, ":", e);
        }
      }
    }

    figma.notify("✅ Preset variables generated!");
    figma.ui.postMessage({ type: "refresh-collections" });
  }


};
